# upgrade connection by default, close connection when upgrade header
# contains an empty string
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

server {
    listen 8080;

    # don't send version banner with requests
    server_tokens off;

    # increase proxy timeouts to 5 minutes
    proxy_read_timeout 300;
    proxy_connect_timeout 300;
    proxy_send_timeout 300;

    # direct error pages to the error location to return no content
    error_page 404 500 502 /error.html;

    location = /error.html {
        internal;

        root /usr/local/openresty/nginx/html;
    }

    location = / {
        return 404;
    }

    location ~ ^/(.*) {
        resolver local=on ipv6=off;
        resolver_timeout 1s;

        set $target '';
        set $path '';

        access_by_lua '
            local location = ngx.var[1]
            local key = nil

            local split_idx = string.find(location, "/")
            if split_idx then
                key = string.sub(location, 1, split_idx - 1)
                ngx.var.path = string.sub(location, split_idx + 1)
            elseif location == "__webpack_hmr" then
                -- this is all just a silly hack to work with webpack\'s hmr which can\'t
                -- work with proxies that use a relative base path (it doesn\'t respect
                -- the relative path and tries to access an absolute path such as
                -- https://router.caas.ai/__webpack_hmr) (at least not with webpack 4,
                -- perhaps with 5 it will work) -
                -- https://github.com/aspnet/JavaScriptServices/issues/488
                -- https://github.com/webpack/webpack-dev-server/issues/252
                -- the solution here is to grab the referer (which should contain the entire
                -- url of the page which is requesting the hmr file) and extract the route
                -- key from it, then route based on that key
                local referer = ngx.var.http_referer -- ngx.header.referer
                if referer then
                    local _, host_end_idx = string.find(referer, ngx.var.http_host)
                    if host_end_idx then
                        split_idx = string.find(referer, "/", host_end_idx + 2)
                        if split_idx then
                            key = string.sub(referer, host_end_idx + 2, split_idx - 1)
                        else
                            key = string.sub(referer, host_end_idx + 2)
                        end

                        -- the path should be the request location, aka "/__webpack_hmr"
                        ngx.var.path = location
                    end
                end
            end

            if not key then
                -- no valid key found
                return ngx.exit(404)
            end

            local redis = require "resty.redis"
            local red = redis:new()

            red:set_timeout(1000, 1000, 1000) -- 1 second

            local ok, err = red:connect("beehive_redis", 6379)
            if not ok then
                ngx.log(ngx.ERR, "failed to connect to redis: ", err)
                return ngx.exit(500)
            end

            -- select db #1 which is used for routing data
            local ok, err = red:select(1)
            if not ok then
                ngx.log(ngx.ERR, "failed to select database #1: ", err)
                return ngx.exit(500)
            end

            local host, err = red:get(key)
            if not host then
                ngx.log(ngx.ERR, "failed to get redis key: ", err)
                return ngx.exit(500)
            end

            if host == ngx.null then
                ngx.log(ngx.ERR, "no host found for key ", key)
                return ngx.exit(404)
            end

            ngx.var.target = host

            -- put connection in pool of size 100 with 10 seconds max idle time
            local ok, err = red:set_keepalive(10000, 100)
            if not ok then
                ngx.log(ngx.ERR, "failed to keep connection in pool: ", err)
                return ngx.exit(500)
            end
        ';

        proxy_http_version 1.1;

        proxy_pass $target$path;
        proxy_set_header Host $host;

        # upgrade headers for websocket proxying. this shouldn't bother normal
        # http services
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }
}
